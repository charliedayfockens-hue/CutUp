<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CutUp - Highway Traffic Racing</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
  #gameCanvas { display: block; width: 100vw; height: 100vh; }

  /* HUD */
  #hud {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 10;
  }
  #speed-display {
    position: absolute; bottom: 40px; right: 40px;
    text-align: right; color: #fff;
  }
  #speed-display .speed-value {
    font-size: 72px; font-weight: 700; line-height: 1;
    text-shadow: 0 0 20px rgba(0,200,255,0.5);
  }
  #speed-display .speed-unit {
    font-size: 18px; color: #aaa; letter-spacing: 2px;
  }
  #score-display {
    position: absolute; top: 30px; right: 40px;
    text-align: right; color: #fff;
  }
  #score-display .score-label {
    font-size: 12px; color: #888; letter-spacing: 3px; text-transform: uppercase;
  }
  #score-display .score-value {
    font-size: 36px; font-weight: 700;
    text-shadow: 0 0 15px rgba(255,200,0,0.5);
  }
  #near-miss-popup {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px; font-weight: 700; color: #ff0;
    text-shadow: 0 0 20px rgba(255,255,0,0.7);
    opacity: 0; transition: opacity 0.1s;
    pointer-events: none;
  }
  #near-miss-popup.show {
    opacity: 1;
  }

  /* Heat Meter */
  #heat-container {
    position: absolute; bottom: 40px; left: 40px;
    width: 200px;
  }
  #heat-label {
    font-size: 12px; color: #888; letter-spacing: 3px;
    text-transform: uppercase; margin-bottom: 6px;
  }
  #heat-bar-bg {
    width: 100%; height: 8px; background: rgba(255,255,255,0.1);
    border-radius: 4px; overflow: hidden;
  }
  #heat-bar {
    width: 0%; height: 100%; border-radius: 4px;
    background: linear-gradient(90deg, #0f0, #ff0, #f00);
    transition: width 0.3s;
  }
  #heat-value {
    font-size: 14px; color: #fff; margin-top: 4px;
  }

  /* Start Screen */
  #start-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100; color: #fff;
  }
  #start-screen h1 {
    font-size: 80px; font-weight: 900;
    background: linear-gradient(135deg, #00d4ff, #ff0080);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    margin-bottom: 10px; letter-spacing: -2px;
  }
  #start-screen .subtitle {
    font-size: 16px; color: #888; margin-bottom: 40px; letter-spacing: 4px;
  }
  #start-screen .controls-info {
    font-size: 14px; color: #666; margin-bottom: 30px; text-align: center; line-height: 2;
  }
  #start-screen .controls-info kbd {
    background: rgba(255,255,255,0.1); padding: 4px 10px; border-radius: 4px;
    border: 1px solid rgba(255,255,255,0.2); font-family: inherit;
  }
  #start-btn {
    pointer-events: all; cursor: pointer;
    background: linear-gradient(135deg, #00d4ff, #0080ff);
    border: none; color: #fff; font-size: 18px; font-weight: 700;
    padding: 16px 60px; border-radius: 50px; letter-spacing: 2px;
    text-transform: uppercase;
    box-shadow: 0 0 30px rgba(0,100,255,0.4);
    transition: transform 0.2s, box-shadow 0.2s;
  }
  #start-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 50px rgba(0,100,255,0.6);
  }

  /* Game Over */
  #game-over {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9);
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100; color: #fff;
  }
  #game-over h2 {
    font-size: 48px; color: #f00; margin-bottom: 20px;
    text-shadow: 0 0 30px rgba(255,0,0,0.5);
  }
  #game-over .final-score {
    font-size: 24px; color: #ccc; margin-bottom: 30px;
  }
  #restart-btn {
    pointer-events: all; cursor: pointer;
    background: linear-gradient(135deg, #ff0040, #ff4080);
    border: none; color: #fff; font-size: 16px; font-weight: 700;
    padding: 14px 50px; border-radius: 50px; letter-spacing: 2px;
    text-transform: uppercase;
  }

  /* Combo Display */
  #combo-display {
    position: absolute; top: 50%; right: 40px;
    transform: translateY(-50%);
    text-align: right; color: #ff0;
    font-size: 20px; font-weight: 700;
    text-shadow: 0 0 15px rgba(255,255,0,0.5);
    opacity: 0; transition: opacity 0.3s;
  }
  #combo-display.active { opacity: 1; }

  /* Speed Lines Overlay */
  #speed-lines {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 5;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(255,255,255,0.03) 100%);
    opacity: 0; transition: opacity 0.5s;
  }

  /* Mobile Controls */
  #mobile-controls {
    position: fixed; bottom: 0; left: 0; width: 100%; height: 180px;
    pointer-events: none; z-index: 20; display: none;
  }
  .mobile-btn {
    position: absolute; pointer-events: all;
    width: 70px; height: 70px; border-radius: 50%;
    background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3);
    display: flex; align-items: center; justify-content: center;
    font-size: 28px; color: rgba(255,255,255,0.7);
    user-select: none; -webkit-user-select: none;
  }
  .mobile-btn:active { background: rgba(255,255,255,0.3); }
  #btn-left { left: 30px; bottom: 60px; }
  #btn-right { left: 120px; bottom: 60px; }
  #btn-gas { right: 30px; bottom: 90px; }
  #btn-brake { right: 120px; bottom: 40px; }
</style>
</head>
<body>

<!-- Start Screen -->
<div id="start-screen">
  <h1>CUTUP</h1>
  <div class="subtitle">HIGHWAY TRAFFIC RACING</div>
  <div class="controls-info">
    <kbd>W</kbd> / <kbd>&#x2191;</kbd> Accelerate &nbsp;&nbsp;
    <kbd>S</kbd> / <kbd>&#x2193;</kbd> Brake<br>
    <kbd>A</kbd> / <kbd>&#x2190;</kbd> Steer Left &nbsp;&nbsp;
    <kbd>D</kbd> / <kbd>&#x2192;</kbd> Steer Right<br>
    <kbd>Space</kbd> Handbrake / Drift
  </div>
  <button id="start-btn" onclick="startGame()">RACE</button>
</div>

<!-- Game Over Screen -->
<div id="game-over">
  <h2>WRECKED</h2>
  <div class="final-score">Score: <span id="final-score-value">0</span></div>
  <button id="restart-btn" onclick="restartGame()">TRY AGAIN</button>
</div>

<!-- HUD -->
<div id="hud" style="display:none;">
  <div id="score-display">
    <div class="score-label">Score</div>
    <div class="score-value" id="score-value">0</div>
  </div>
  <div id="speed-display">
    <div class="speed-value" id="speed-value">0</div>
    <div class="speed-unit">KM/H</div>
  </div>
  <div id="heat-container">
    <div id="heat-label">Heat</div>
    <div id="heat-bar-bg"><div id="heat-bar"></div></div>
    <div id="heat-value">0%</div>
  </div>
  <div id="near-miss-popup">NEAR MISS!</div>
  <div id="combo-display"></div>
</div>
<div id="speed-lines"></div>

<!-- Mobile Controls -->
<div id="mobile-controls">
  <div class="mobile-btn" id="btn-left">&#9664;</div>
  <div class="mobile-btn" id="btn-right">&#9654;</div>
  <div class="mobile-btn" id="btn-gas">&#9650;</div>
  <div class="mobile-btn" id="btn-brake">&#9660;</div>
</div>

<canvas id="gameCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
<script>
// ============================================================
// CUTUP - 3D Highway Traffic Racing Game
// ============================================================

// --- Globals ---
let scene, camera, renderer, clock;
let world; // Cannon.js physics world
let playerCar, playerBody;
let gameState = 'menu'; // menu, playing, gameover
let score = 0;
let speed = 0;
let heat = 0;
let distanceTraveled = 0;
let nearMissTimer = 0;
let nearMissCombo = 0;
let nearMissComboTimer = 0;
let screenShake = 0;
let dayNightCycle = 0;
let sunLight, ambientLight, hemisphereLight;
let fog;

// Input
const keys = {};
let touchControls = { left: false, right: false, gas: false, brake: false };

// Object pools
const ROAD_SEGMENT_COUNT = 20;
const TRAFFIC_POOL_SIZE = 30;
const roadSegments = [];
const trafficPool = [];
const activeTraffic = [];

// Highway config
const LANE_WIDTH = 3.8;
const LANE_COUNT = 4;
const ROAD_WIDTH = LANE_COUNT * LANE_WIDTH + 4; // extra for shoulders
const SEGMENT_LENGTH = 60;
const ROAD_HALF_WIDTH = ROAD_WIDTH / 2;

// Player config
const MAX_SPEED = 280; // km/h
const ACCELERATION = 45;
const BRAKING_FORCE = 60;
const ENGINE_BRAKE = 8;
const STEER_SPEED = 2.8;
const STEER_RETURN = 4.0;
const DRIFT_FACTOR = 0.92;
const GRIP_FACTOR = 0.96;
const MAX_STEER = 0.6;

// Traffic config
const MIN_TRAFFIC_SPEED = 60;
const MAX_TRAFFIC_SPEED = 120;
const TRAFFIC_SPAWN_DISTANCE = 300;
const TRAFFIC_DESPAWN_DISTANCE = 80;
const LANE_CHANGE_CHANCE = 0.003;

// Near-miss config
const NEAR_MISS_THRESHOLD = 2.5;
const NEAR_MISS_BONUS = 50;

// Colors
const CAR_COLORS = [
  0xff3333, 0x3333ff, 0x33ff33, 0xffff33, 0xff33ff,
  0x33ffff, 0xff8833, 0x8833ff, 0xffffff, 0x333333,
  0xff6600, 0x0066ff, 0x00cc44, 0xcc0044
];

// ============================================================
// INITIALIZATION
// ============================================================

function init() {
  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  fog = new THREE.FogExp2(0x87CEEB, 0.0025);
  scene.fog = fog;

  // Clock
  clock = new THREE.Clock();

  // Camera
  camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.5, 1000);
  camera.position.set(0, 6, -12);
  camera.lookAt(0, 1, 10);

  // Renderer
  const canvas = document.getElementById('gameCanvas');
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;

  // Lighting
  setupLighting();

  // Physics
  setupPhysics();

  // Build scene objects
  createGround();
  createRoadSegmentPool();
  createPlayerCar();
  createTrafficPool();

  // Input
  setupInput();

  // Mobile detect
  if ('ontouchstart' in window) {
    document.getElementById('mobile-controls').style.display = 'block';
    setupMobileControls();
  }

  // Resize
  window.addEventListener('resize', onResize);

  // Start render loop
  animate();
}

// ============================================================
// LIGHTING & ATMOSPHERE
// ============================================================

function setupLighting() {
  // Hemisphere
  hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x362d1c, 0.5);
  scene.add(hemisphereLight);

  // Ambient
  ambientLight = new THREE.AmbientLight(0x404040, 0.4);
  scene.add(ambientLight);

  // Sun (directional)
  sunLight = new THREE.DirectionalLight(0xfff0dd, 1.2);
  sunLight.position.set(50, 80, 30);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.near = 1;
  sunLight.shadow.camera.far = 200;
  sunLight.shadow.camera.left = -50;
  sunLight.shadow.camera.right = 50;
  sunLight.shadow.camera.top = 50;
  sunLight.shadow.camera.bottom = -50;
  scene.add(sunLight);
}

function updateDayNightCycle(dt) {
  dayNightCycle += dt * 0.02; // Full cycle ~5 min
  const t = (Math.sin(dayNightCycle) + 1) / 2; // 0=night, 1=day

  // Sun position
  const sunAngle = dayNightCycle;
  sunLight.position.set(
    Math.cos(sunAngle) * 80,
    Math.sin(sunAngle) * 80 + 10,
    30
  );

  // Light intensities
  sunLight.intensity = THREE.MathUtils.lerp(0.05, 1.3, t);
  ambientLight.intensity = THREE.MathUtils.lerp(0.08, 0.4, t);
  hemisphereLight.intensity = THREE.MathUtils.lerp(0.1, 0.5, t);

  // Sky color
  const dayColor = new THREE.Color(0x87CEEB);
  const nightColor = new THREE.Color(0x0a0a2e);
  const sunsetColor = new THREE.Color(0xff6633);

  let skyColor;
  if (t > 0.5) {
    skyColor = nightColor.clone().lerp(dayColor, (t - 0.5) * 2);
  } else {
    skyColor = nightColor.clone().lerp(sunsetColor, t * 2);
  }

  scene.background = skyColor;
  fog.color = skyColor;

  // Sun light color
  const dayLightColor = new THREE.Color(0xfff5e0);
  const sunsetLightColor = new THREE.Color(0xff6622);
  const nightLightColor = new THREE.Color(0x223366);
  if (t > 0.6) {
    sunLight.color = sunsetLightColor.clone().lerp(dayLightColor, (t - 0.6) / 0.4);
  } else if (t > 0.3) {
    sunLight.color = nightLightColor.clone().lerp(sunsetLightColor, (t - 0.3) / 0.3);
  } else {
    sunLight.color = nightLightColor;
  }

  // Fog density
  fog.density = THREE.MathUtils.lerp(0.006, 0.0025, t);

  // Exposure
  renderer.toneMappingExposure = THREE.MathUtils.lerp(0.3, 1.0, t);
}

// ============================================================
// PHYSICS (Cannon.js)
// ============================================================

function setupPhysics() {
  world = new CANNON.World();
  world.gravity.set(0, -9.82, 0);
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 10;
  world.defaultContactMaterial.friction = 0.3;
  world.defaultContactMaterial.restitution = 0.1;

  // Ground plane
  const groundBody = new CANNON.Body({ mass: 0 });
  groundBody.addShape(new CANNON.Plane());
  groundBody.quaternion.setFromEulerAngles(-Math.PI / 2, 0, 0);
  world.addBody(groundBody);
}

// ============================================================
// GROUND & ENVIRONMENT
// ============================================================

function createGround() {
  // Large ground plane
  const groundGeo = new THREE.PlaneGeometry(2000, 2000);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0x3a5f2c,
    roughness: 0.9,
    metalness: 0.0
  });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.05;
  ground.receiveShadow = true;
  scene.add(ground);
}

// ============================================================
// ROAD SEGMENT POOL
// ============================================================

function createRoadSegmentPool() {
  for (let i = 0; i < ROAD_SEGMENT_COUNT; i++) {
    const segment = createRoadSegment();
    segment.position.z = i * SEGMENT_LENGTH;
    segment.userData.index = i;
    roadSegments.push(segment);
    scene.add(segment);
  }
}

function createRoadSegment() {
  const group = new THREE.Group();

  // Main road surface
  const roadGeo = new THREE.PlaneGeometry(ROAD_WIDTH, SEGMENT_LENGTH);
  const roadMat = new THREE.MeshStandardMaterial({
    color: 0x333338,
    roughness: 0.8,
    metalness: 0.1
  });
  const road = new THREE.Mesh(roadGeo, roadMat);
  road.rotation.x = -Math.PI / 2;
  road.position.y = 0.01;
  road.receiveShadow = true;
  group.add(road);

  // Lane markings
  const dashLength = 3;
  const dashGap = 4;
  const dashGeo = new THREE.PlaneGeometry(0.15, dashLength);
  const dashMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
  const solidGeo = new THREE.PlaneGeometry(0.2, SEGMENT_LENGTH);
  const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.5 });

  // Center divider (double yellow)
  for (const offset of [-0.2, 0.2]) {
    const divider = new THREE.Mesh(solidGeo, yellowMat);
    divider.rotation.x = -Math.PI / 2;
    divider.position.set(offset, 0.02, 0);
    group.add(divider);
  }

  // Lane dashes
  for (let lane = 1; lane < LANE_COUNT / 2; lane++) {
    for (let side of [-1, 1]) {
      const x = side * (lane * LANE_WIDTH);
      for (let d = -SEGMENT_LENGTH / 2; d < SEGMENT_LENGTH / 2; d += dashLength + dashGap) {
        const dash = new THREE.Mesh(dashGeo, dashMat);
        dash.rotation.x = -Math.PI / 2;
        dash.position.set(x, 0.02, d + dashLength / 2);
        group.add(dash);
      }
    }
  }

  // Edge lines (solid white)
  const edgeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
  for (const side of [-1, 1]) {
    const edge = new THREE.Mesh(solidGeo, edgeMat);
    edge.rotation.x = -Math.PI / 2;
    edge.position.set(side * (ROAD_HALF_WIDTH - 1.5), 0.02, 0);
    group.add(edge);
  }

  // Barriers / guardrails
  const barrierGeo = new THREE.BoxGeometry(0.3, 0.8, SEGMENT_LENGTH);
  const barrierMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.6, metalness: 0.4 });
  for (const side of [-1, 1]) {
    const barrier = new THREE.Mesh(barrierGeo, barrierMat);
    barrier.position.set(side * (ROAD_HALF_WIDTH + 0.15), 0.4, 0);
    barrier.castShadow = true;
    barrier.receiveShadow = true;
    group.add(barrier);
  }

  // Roadside details - lamp posts every segment
  for (const side of [-1, 1]) {
    const poleGeo = new THREE.CylinderGeometry(0.08, 0.08, 6, 6);
    const poleMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.5 });
    const pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.set(side * (ROAD_HALF_WIDTH + 2), 3, 0);
    pole.castShadow = true;
    group.add(pole);

    // Lamp head
    const lampGeo = new THREE.SphereGeometry(0.3, 8, 8);
    const lampMat = new THREE.MeshStandardMaterial({
      color: 0xffffcc, emissive: 0xffffaa, emissiveIntensity: 0.3
    });
    const lamp = new THREE.Mesh(lampGeo, lampMat);
    lamp.position.set(side * (ROAD_HALF_WIDTH + 2), 6, 0);
    group.add(lamp);
  }

  return group;
}

function updateRoadSegments() {
  const playerZ = playerCar.position.z;
  for (const seg of roadSegments) {
    if (seg.position.z < playerZ - SEGMENT_LENGTH * 2) {
      // Recycle segment ahead
      const maxZ = Math.max(...roadSegments.map(s => s.position.z));
      seg.position.z = maxZ + SEGMENT_LENGTH;
    }
  }
}

// ============================================================
// PLAYER CAR
// ============================================================

function createPlayerCar() {
  playerCar = new THREE.Group();

  // Car body - main chassis
  const bodyGeo = new THREE.BoxGeometry(2.0, 0.6, 4.2);
  const bodyMat = new THREE.MeshStandardMaterial({
    color: 0xff2200,
    roughness: 0.3,
    metalness: 0.7
  });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.5;
  body.castShadow = true;
  playerCar.add(body);

  // Cabin / roof
  const cabinGeo = new THREE.BoxGeometry(1.7, 0.5, 2.0);
  const cabinMat = new THREE.MeshStandardMaterial({
    color: 0x222244,
    roughness: 0.1,
    metalness: 0.9,
    transparent: true,
    opacity: 0.7
  });
  const cabin = new THREE.Mesh(cabinGeo, cabinMat);
  cabin.position.set(0, 1.0, -0.3);
  cabin.castShadow = true;
  playerCar.add(cabin);

  // Front spoiler
  const spoilerFGeo = new THREE.BoxGeometry(2.1, 0.15, 0.4);
  const spoilerFMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.5 });
  const spoilerF = new THREE.Mesh(spoilerFGeo, spoilerFMat);
  spoilerF.position.set(0, 0.25, 2.2);
  playerCar.add(spoilerF);

  // Rear wing
  const wingGeo = new THREE.BoxGeometry(2.0, 0.08, 0.35);
  const wingMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3, metalness: 0.6 });
  const wing = new THREE.Mesh(wingGeo, wingMat);
  wing.position.set(0, 1.3, -2.0);
  playerCar.add(wing);

  // Wing supports
  for (const sx of [-0.7, 0.7]) {
    const supportGeo = new THREE.BoxGeometry(0.08, 0.3, 0.08);
    const support = new THREE.Mesh(supportGeo, wingMat);
    support.position.set(sx, 1.15, -2.0);
    playerCar.add(support);
  }

  // Wheels
  const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6, metalness: 0.3 });
  const wheelPositions = [
    [-1.0, 0.35, 1.3], [1.0, 0.35, 1.3],
    [-1.0, 0.35, -1.3], [1.0, 0.35, -1.3]
  ];
  playerCar.userData.wheels = [];
  for (const [x, y, z] of wheelPositions) {
    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
    wheel.rotation.z = Math.PI / 2;
    wheel.position.set(x, y, z);
    wheel.castShadow = true;
    playerCar.add(wheel);
    playerCar.userData.wheels.push(wheel);
  }

  // Headlights
  for (const sx of [-0.7, 0.7]) {
    const hlGeo = new THREE.SphereGeometry(0.15, 8, 8);
    const hlMat = new THREE.MeshStandardMaterial({
      color: 0xffffff, emissive: 0xffffcc, emissiveIntensity: 0.5
    });
    const hl = new THREE.Mesh(hlGeo, hlMat);
    hl.position.set(sx, 0.55, 2.15);
    playerCar.add(hl);
  }

  // Tail lights
  for (const sx of [-0.7, 0.7]) {
    const tlGeo = new THREE.BoxGeometry(0.3, 0.12, 0.05);
    const tlMat = new THREE.MeshStandardMaterial({
      color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.4
    });
    const tl = new THREE.Mesh(tlGeo, tlMat);
    tl.position.set(sx, 0.55, -2.15);
    playerCar.add(tl);
  }

  playerCar.position.set(0, 0, 0);
  scene.add(playerCar);

  // Physics body
  const halfExtents = new CANNON.Vec3(1.0, 0.4, 2.1);
  const boxShape = new CANNON.Box(halfExtents);
  playerBody = new CANNON.Body({
    mass: 1200,
    position: new CANNON.Vec3(0, 0.8, 0),
    linearDamping: 0.1,
    angularDamping: 0.95
  });
  playerBody.addShape(boxShape, new CANNON.Vec3(0, 0.3, 0));
  world.addBody(playerBody);

  // Vehicle state
  playerCar.userData.speed = 0;
  playerCar.userData.steer = 0;
  playerCar.userData.drifting = false;
  playerCar.userData.lateralVelocity = 0;
}

// ============================================================
// TRAFFIC POOL
// ============================================================

function createTrafficPool() {
  for (let i = 0; i < TRAFFIC_POOL_SIZE; i++) {
    const car = createTrafficCar();
    car.visible = false;
    car.userData.active = false;
    car.userData.speed = 0;
    car.userData.lane = 0;
    car.userData.targetLane = 0;
    car.userData.laneChangeTimer = 0;
    car.userData.nearMissCounted = false;
    trafficPool.push(car);
    scene.add(car);
  }
}

function createTrafficCar() {
  const group = new THREE.Group();
  const color = CAR_COLORS[Math.floor(Math.random() * CAR_COLORS.length)];

  // Randomly pick car type: sedan, SUV, or truck
  const type = Math.random();

  if (type < 0.5) {
    // Sedan
    const bodyGeo = new THREE.BoxGeometry(1.9, 0.55, 4.0);
    const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.35, metalness: 0.6 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.5;
    body.castShadow = true;
    group.add(body);

    const cabGeo = new THREE.BoxGeometry(1.6, 0.45, 1.8);
    const cabMat = new THREE.MeshStandardMaterial({
      color: 0x334455, roughness: 0.1, metalness: 0.8, transparent: true, opacity: 0.6
    });
    const cab = new THREE.Mesh(cabGeo, cabMat);
    cab.position.set(0, 0.97, -0.2);
    group.add(cab);

    group.userData.halfLength = 2.0;
    group.userData.halfWidth = 0.95;
  } else if (type < 0.8) {
    // SUV
    const bodyGeo = new THREE.BoxGeometry(2.1, 0.8, 4.5);
    const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.5 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.65;
    body.castShadow = true;
    group.add(body);

    const cabGeo = new THREE.BoxGeometry(1.8, 0.55, 2.2);
    const cabMat = new THREE.MeshStandardMaterial({
      color: 0x334455, roughness: 0.1, metalness: 0.8, transparent: true, opacity: 0.6
    });
    const cab = new THREE.Mesh(cabGeo, cabMat);
    cab.position.set(0, 1.3, -0.3);
    group.add(cab);

    group.userData.halfLength = 2.25;
    group.userData.halfWidth = 1.05;
  } else {
    // Truck / van
    const bodyGeo = new THREE.BoxGeometry(2.2, 1.5, 5.5);
    const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.5, metalness: 0.3 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.95;
    body.castShadow = true;
    group.add(body);

    group.userData.halfLength = 2.75;
    group.userData.halfWidth = 1.1;
  }

  // Wheels for all types
  const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 12);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 });
  for (const [x, z] of [[-0.85, 1.2], [0.85, 1.2], [-0.85, -1.2], [0.85, -1.2]]) {
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI / 2;
    w.position.set(x, 0.3, z);
    group.add(w);
  }

  // Tail lights
  for (const sx of [-0.6, 0.6]) {
    const tlGeo = new THREE.BoxGeometry(0.2, 0.1, 0.05);
    const tlMat = new THREE.MeshStandardMaterial({
      color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3
    });
    const tl = new THREE.Mesh(tlGeo, tlMat);
    tl.position.set(sx, 0.55, -(group.userData.halfLength || 2.0));
    group.add(tl);
  }

  return group;
}

function getInactiveTraffic() {
  for (const car of trafficPool) {
    if (!car.userData.active) return car;
  }
  return null;
}

function laneToX(lane) {
  // Lanes: 0,1 are on the right side (player direction), 2,3 oncoming
  // But for simplicity, lanes -1, 0, 1, 2 centered
  const laneOffset = (lane - (LANE_COUNT - 1) / 2) * LANE_WIDTH;
  return laneOffset;
}

function spawnTraffic() {
  if (gameState !== 'playing') return;

  const playerZ = playerCar.position.z;
  const targetActiveCount = Math.min(TRAFFIC_POOL_SIZE, 12 + Math.floor(distanceTraveled / 500));

  let activeCount = 0;
  for (const car of trafficPool) {
    if (car.userData.active) activeCount++;
  }

  if (activeCount < targetActiveCount) {
    const car = getInactiveTraffic();
    if (!car) return;

    const lane = Math.floor(Math.random() * LANE_COUNT);
    const x = laneToX(lane);
    const z = playerZ + TRAFFIC_SPAWN_DISTANCE + Math.random() * 100;

    // Check for overlapping spawns
    for (const other of trafficPool) {
      if (other.userData.active && Math.abs(other.position.z - z) < 10 && Math.abs(other.position.x - x) < 3) {
        return; // Skip spawn
      }
    }

    car.visible = true;
    car.userData.active = true;
    car.userData.lane = lane;
    car.userData.targetLane = lane;
    car.userData.speed = MIN_TRAFFIC_SPEED + Math.random() * (MAX_TRAFFIC_SPEED - MIN_TRAFFIC_SPEED);
    car.userData.laneChangeTimer = 0;
    car.userData.nearMissCounted = false;
    car.position.set(x, 0, z);
    car.rotation.set(0, 0, 0);

    // Re-color the car
    const newColor = CAR_COLORS[Math.floor(Math.random() * CAR_COLORS.length)];
    car.children[0].material.color.setHex(newColor);
  }
}

function updateTraffic(dt) {
  const playerZ = playerCar.position.z;

  for (const car of trafficPool) {
    if (!car.userData.active) continue;

    // Move forward
    const speedMs = car.userData.speed / 3.6; // km/h to m/s
    car.position.z += speedMs * dt;

    // Lane changing AI
    car.userData.laneChangeTimer -= dt;
    if (car.userData.laneChangeTimer <= 0 && Math.random() < LANE_CHANGE_CHANCE) {
      const dir = Math.random() < 0.5 ? -1 : 1;
      const newLane = car.userData.targetLane + dir;
      if (newLane >= 0 && newLane < LANE_COUNT) {
        // Check if new lane is clear
        let clear = true;
        for (const other of trafficPool) {
          if (other === car || !other.userData.active) continue;
          if (other.userData.lane === newLane &&
              Math.abs(other.position.z - car.position.z) < 12) {
            clear = false;
            break;
          }
        }
        if (clear) {
          car.userData.targetLane = newLane;
          car.userData.laneChangeTimer = 3 + Math.random() * 5;
        }
      }
    }

    // Smooth lane transition
    const targetX = laneToX(car.userData.targetLane);
    car.position.x += (targetX - car.position.x) * dt * 2;
    if (Math.abs(car.position.x - targetX) < 0.1) {
      car.userData.lane = car.userData.targetLane;
    }

    // Despawn if behind player
    if (car.position.z < playerZ - TRAFFIC_DESPAWN_DISTANCE) {
      car.visible = false;
      car.userData.active = false;
    }

    // Near-miss detection
    if (!car.userData.nearMissCounted) {
      const dx = Math.abs(car.position.x - playerCar.position.x);
      const dz = Math.abs(car.position.z - playerCar.position.z);
      if (dx < NEAR_MISS_THRESHOLD && dz < 5) {
        // Close laterally and passing
        if (playerCar.userData.speed > car.userData.speed * 1.2) {
          car.userData.nearMissCounted = true;
          triggerNearMiss();
        }
      }
    }
  }
}

// ============================================================
// COLLISION DETECTION
// ============================================================

function checkCollisions() {
  const px = playerCar.position.x;
  const pz = playerCar.position.z;
  const pHalfW = 1.0;
  const pHalfL = 2.1;

  for (const car of trafficPool) {
    if (!car.userData.active) continue;

    const cx = car.position.x;
    const cz = car.position.z;
    const cHalfW = car.userData.halfWidth || 0.95;
    const cHalfL = car.userData.halfLength || 2.0;

    // AABB collision
    if (Math.abs(px - cx) < (pHalfW + cHalfW) * 0.85 &&
        Math.abs(pz - cz) < (pHalfL + cHalfL) * 0.85) {
      triggerCrash();
      return;
    }
  }

  // Barrier collision
  if (Math.abs(px) > ROAD_HALF_WIDTH - 1.5) {
    // Bounce off barrier
    playerCar.userData.lateralVelocity *= -0.5;
    playerCar.position.x = Math.sign(px) * (ROAD_HALF_WIDTH - 1.6);
    playerCar.userData.speed *= 0.9;
    heat = Math.min(100, heat + 5);
  }
}

// ============================================================
// PLAYER CONTROLLER
// ============================================================

function updatePlayer(dt) {
  if (gameState !== 'playing') return;

  const car = playerCar.userData;
  const isGas = keys['KeyW'] || keys['ArrowUp'] || touchControls.gas;
  const isBrake = keys['KeyS'] || keys['ArrowDown'] || touchControls.brake;
  const isLeft = keys['KeyA'] || keys['ArrowLeft'] || touchControls.left;
  const isRight = keys['KeyD'] || keys['ArrowRight'] || touchControls.right;
  const isDrift = keys['Space'];

  // Acceleration / braking
  if (isGas) {
    car.speed = Math.min(MAX_SPEED, car.speed + ACCELERATION * dt);
  } else if (isBrake) {
    car.speed = Math.max(-20, car.speed - BRAKING_FORCE * dt);
  } else {
    // Engine braking
    if (car.speed > 0) {
      car.speed = Math.max(0, car.speed - ENGINE_BRAKE * dt);
    } else if (car.speed < 0) {
      car.speed = Math.min(0, car.speed + ENGINE_BRAKE * dt);
    }
  }

  // Speed in m/s
  const speedMs = car.speed / 3.6;

  // Steering
  const steerInput = (isLeft ? 1 : 0) - (isRight ? 1 : 0);
  if (steerInput !== 0) {
    car.steer += steerInput * STEER_SPEED * dt;
    car.steer = THREE.MathUtils.clamp(car.steer, -MAX_STEER, MAX_STEER);
  } else {
    // Return to center
    if (Math.abs(car.steer) < 0.05) {
      car.steer = 0;
    } else {
      car.steer -= Math.sign(car.steer) * STEER_RETURN * dt;
    }
  }

  // Apply steering to lateral movement
  const steerFactor = Math.min(1, Math.abs(speedMs) / 10); // Less steering at low speed
  const lateralForce = car.steer * speedMs * 0.6 * steerFactor;

  // Drifting
  if (isDrift && Math.abs(speedMs) > 5) {
    car.drifting = true;
    car.lateralVelocity += lateralForce * dt * 2;
    car.lateralVelocity *= DRIFT_FACTOR;
    car.speed *= 0.998; // Slight speed loss while drifting
    heat = Math.min(100, heat + 15 * dt);
  } else {
    car.drifting = false;
    car.lateralVelocity += lateralForce * dt;
    car.lateralVelocity *= GRIP_FACTOR;
  }

  // Update position
  playerCar.position.z += speedMs * dt;
  playerCar.position.x -= car.lateralVelocity * dt;
  playerCar.position.y = 0;

  // Car rotation (visual tilt)
  const tiltAngle = -car.steer * 0.15;
  const rollAngle = car.lateralVelocity * 0.02;
  playerCar.rotation.y = car.steer * 0.3;
  playerCar.rotation.z = rollAngle;
  playerCar.rotation.x = tiltAngle;

  // Sync physics body position (simplified - we use position directly)
  playerBody.position.set(playerCar.position.x, 0.8, playerCar.position.z);

  // Wheel spin
  const wheelSpin = speedMs * dt * 3;
  if (car.wheels) {
    for (const wheel of car.wheels) {
      wheel.rotation.x += wheelSpin;
    }
  }

  // Distance and score
  distanceTraveled += Math.abs(speedMs) * dt;
  score += Math.abs(speedMs) * dt * 0.5;

  // Heat decay
  if (!car.drifting) {
    heat = Math.max(0, heat - 5 * dt);
  }

  // Heat penalty
  if (heat >= 100) {
    car.speed *= 0.99;
  }

  speed = Math.abs(car.speed);
}

// ============================================================
// CAMERA
// ============================================================

function updateCamera(dt) {
  if (gameState !== 'playing') return;

  const car = playerCar;
  const speedRatio = speed / MAX_SPEED;

  // Dynamic camera distance based on speed
  const baseDist = 12;
  const baseHeight = 5.5;
  const camDist = baseDist + speedRatio * 4;
  const camHeight = baseHeight + speedRatio * 1.5;

  // Camera offset accounting for steering
  const lateralOffset = -playerCar.userData.steer * 1.5;

  const targetX = car.position.x + lateralOffset;
  const targetY = car.position.y + camHeight;
  const targetZ = car.position.z - camDist;

  // Smooth follow
  const smoothing = 4 * dt;
  camera.position.x += (targetX - camera.position.x) * smoothing;
  camera.position.y += (targetY - camera.position.y) * smoothing * 0.8;
  camera.position.z += (targetZ - camera.position.z) * smoothing;

  // Screen shake
  if (screenShake > 0) {
    camera.position.x += (Math.random() - 0.5) * screenShake * 2;
    camera.position.y += (Math.random() - 0.5) * screenShake;
    screenShake *= 0.9;
    if (screenShake < 0.01) screenShake = 0;
  }

  // Look ahead
  const lookZ = car.position.z + 15 + speedRatio * 20;
  const lookTarget = new THREE.Vector3(car.position.x, car.position.y + 1.5, lookZ);
  camera.lookAt(lookTarget);

  // FOV based on speed (cinematic effect)
  const targetFOV = 65 + speedRatio * 15;
  camera.fov += (targetFOV - camera.fov) * dt * 2;
  camera.updateProjectionMatrix();

  // Update shadow camera to follow player
  sunLight.target.position.set(car.position.x, 0, car.position.z);
  sunLight.position.x = car.position.x + 50;
  sunLight.position.z = car.position.z + 30;
}

// ============================================================
// SCORING & EVENTS
// ============================================================

function triggerNearMiss() {
  // Combo system
  if (nearMissComboTimer > 0) {
    nearMissCombo++;
  } else {
    nearMissCombo = 1;
  }
  nearMissComboTimer = 3.0;

  const bonus = NEAR_MISS_BONUS * nearMissCombo;
  score += bonus;
  nearMissTimer = 1.0;
  heat = Math.min(100, heat + 10);
  screenShake = 0.3;

  const popup = document.getElementById('near-miss-popup');
  popup.classList.add('show');
  if (nearMissCombo > 1) {
    popup.textContent = `NEAR MISS x${nearMissCombo}! +${bonus}`;
  } else {
    popup.textContent = `NEAR MISS! +${bonus}`;
  }
  setTimeout(() => popup.classList.remove('show'), 800);
}

function triggerCrash() {
  gameState = 'gameover';
  document.getElementById('hud').style.display = 'none';
  document.getElementById('game-over').style.display = 'flex';
  document.getElementById('final-score-value').textContent = Math.floor(score);
  document.getElementById('mobile-controls').style.display = 'none';
}

// ============================================================
// HUD UPDATE
// ============================================================

function updateHUD() {
  document.getElementById('speed-value').textContent = Math.floor(speed);
  document.getElementById('score-value').textContent = Math.floor(score);

  const heatBar = document.getElementById('heat-bar');
  heatBar.style.width = heat + '%';
  document.getElementById('heat-value').textContent = Math.floor(heat) + '%';

  // Heat bar color intensity
  if (heat > 80) {
    heatBar.style.filter = 'brightness(1.3)';
  } else {
    heatBar.style.filter = 'none';
  }

  // Combo display
  const comboEl = document.getElementById('combo-display');
  if (nearMissCombo > 1 && nearMissComboTimer > 0) {
    comboEl.classList.add('active');
    comboEl.textContent = `COMBO x${nearMissCombo}`;
  } else {
    comboEl.classList.remove('active');
  }

  // Speed lines intensity
  const speedLines = document.getElementById('speed-lines');
  const speedIntensity = Math.max(0, (speed - 100) / (MAX_SPEED - 100));
  speedLines.style.opacity = speedIntensity * 0.6;
}

// ============================================================
// INPUT
// ============================================================

function setupInput() {
  document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
  });
  document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
  });
}

function setupMobileControls() {
  const addTouchEvents = (id, prop) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); touchControls[prop] = true; });
    el.addEventListener('touchend', (e) => { e.preventDefault(); touchControls[prop] = false; });
    el.addEventListener('touchcancel', (e) => { e.preventDefault(); touchControls[prop] = false; });
  };
  addTouchEvents('btn-left', 'left');
  addTouchEvents('btn-right', 'right');
  addTouchEvents('btn-gas', 'gas');
  addTouchEvents('btn-brake', 'brake');
}

// ============================================================
// RESIZE
// ============================================================

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============================================================
// GAME STATE
// ============================================================

function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  if ('ontouchstart' in window) {
    document.getElementById('mobile-controls').style.display = 'block';
  }

  resetGame();
  gameState = 'playing';
}

function restartGame() {
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  if ('ontouchstart' in window) {
    document.getElementById('mobile-controls').style.display = 'block';
  }

  resetGame();
  gameState = 'playing';
}

function resetGame() {
  score = 0;
  speed = 0;
  heat = 0;
  distanceTraveled = 0;

  // Reset player
  playerCar.position.set(laneToX(1), 0, 0);
  playerCar.rotation.set(0, 0, 0);
  playerCar.userData.speed = 0;
  playerCar.userData.steer = 0;
  playerCar.userData.lateralVelocity = 0;
  playerCar.userData.drifting = false;
  playerBody.position.set(laneToX(1), 0.8, 0);
  playerBody.velocity.setZero();
  playerBody.angularVelocity.setZero();

  // Reset road segments
  for (let i = 0; i < roadSegments.length; i++) {
    roadSegments[i].position.z = i * SEGMENT_LENGTH;
  }

  // Deactivate all traffic
  for (const car of trafficPool) {
    car.visible = false;
    car.userData.active = false;
  }

  // Reset camera
  camera.position.set(laneToX(1), 6, -12);
  camera.fov = 65;
  camera.updateProjectionMatrix();
}

// ============================================================
// MAIN LOOP
// ============================================================

let trafficSpawnAccum = 0;

function animate() {
  requestAnimationFrame(animate);

  const dt = Math.min(clock.getDelta(), 0.05); // Cap delta

  if (gameState === 'playing') {
    // Physics step
    world.step(1 / 60, dt, 3);

    // Update systems
    updatePlayer(dt);
    updateCamera(dt);
    updateRoadSegments();
    updateDayNightCycle(dt);

    // Traffic spawning
    trafficSpawnAccum += dt;
    if (trafficSpawnAccum > 0.3) {
      spawnTraffic();
      trafficSpawnAccum = 0;
    }
    updateTraffic(dt);

    // Collision
    checkCollisions();

    // Near-miss timer
    if (nearMissTimer > 0) {
      nearMissTimer -= dt;
    }
    // Combo timer
    if (nearMissComboTimer > 0) {
      nearMissComboTimer -= dt;
      if (nearMissComboTimer <= 0) {
        nearMissCombo = 0;
      }
    }

    // HUD
    updateHUD();
  }

  renderer.render(scene, camera);
}

// ============================================================
// BOOT
// ============================================================

init();
</script>
</body>
</html>
